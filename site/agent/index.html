
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.40">
    
    
      
        <title>Agent - AIDIY Wiki</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#24-langchain" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="AIDIY Wiki" class="md-header__button md-logo" aria-label="AIDIY Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            AIDIY Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Agent
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../Mathematical_Foundation/Linear_Algebra/Matrix_Decomposition/Full_Rank_Decomposition/" class="md-tabs__link">
          
  
  数学基础

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../ML_Pages/CNN/" class="md-tabs__link">
          
  
  Machine Learning

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../LLM_Pages/Math_Architecture/" class="md-tabs__link">
          
  
  LLM

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../Engineering_Pages/LlamaFactory/" class="md-tabs__link">
          
  
  工程实践

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../RL_Pages/RL/" class="md-tabs__link">
          
  
  RL

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../RLHF_Pages/PPO/" class="md-tabs__link">
          
  
  LLM_RLHF阶段

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../stablediffusion/" class="md-tabs__link">
        
  
    
  
  StableDiffusion

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="AIDIY Wiki" class="md-nav__button md-logo" aria-label="AIDIY Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    AIDIY Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数学基础
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            数学基础
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Mathematical_Foundation/Linear_Algebra/Matrix_Decomposition/Full_Rank_Decomposition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    矩阵满秩分解
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Mathematical_Foundation/Linear_Algebra/Matrix_Calculation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    矩阵求导
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Mathematical_Foundation/Manifold/Manifold_hypothesis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    流形假设
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Machine Learning
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Machine Learning
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ML_Pages/CNN/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CNN
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ML_Pages/MLP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MLP
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ML_Pages/RNN/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RNN
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ML_Pages/VAE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    VAE
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    LLM
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            LLM
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../LLM_Pages/Math_Architecture/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Transformer数学架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../LLM_Pages/Position_Embedding/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    位置编码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../LLM_Pages/Pre-Train/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    预训练阶段
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../LLM_Pages/SFT/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SFT阶段
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../LLM_Pages/Post-Train/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    后训练阶段
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    工程实践
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            工程实践
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Engineering_Pages/LlamaFactory/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LlamaFactory入门
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Engineering_Pages/VLLM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    vllm部署模型
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Engineering_Pages/Full_SFT_LlamaFactory/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    全量微调
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    RL
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            RL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RL_Pages/RL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RL基础概念
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RL_Pages/Monte_Carlos/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    蒙特卡洛树搜索
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    LLM_RLHF阶段
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            LLM_RLHF阶段
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RLHF_Pages/PPO/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PPO
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RLHF_Pages/DPO/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DPO
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RLHF_Pages/SimPO/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SimPO
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RLHF_Pages/DPO_Exercise/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DPO_Exercice
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RLHF_Pages/SimPO_Exercise/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SimPO_Exercice
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../stablediffusion/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    StableDiffusion
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#24-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4 大模型 langchain
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2.4 大模型 langchain">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#241-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.1 什么是LangChain?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.2 LangChain 包含哪些核心概念?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#243-langchain-agent" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.3 什么是LangChain Agent?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#244-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.4 如何使用LangChain?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#247-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.7 LangChain 包含哪些特点?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#248-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.8 LangChain 存在哪些问题及方法方案?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#249-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.9 LangChain 替代方案?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2424-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.24 LangChain 行为不一致并且隐藏细节问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2425-langchain" class="md-nav__link">
    <span class="md-ellipsis">
      2.4.25 LangChain 缺乏标准的可互操作数据类型问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25-llm" class="md-nav__link">
    <span class="md-ellipsis">
      2.5 基于LLM+向量库的文档对话
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2.5 基于LLM+向量库的文档对话">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251-llms" class="md-nav__link">
    <span class="md-ellipsis">
      2.5.1 LLMs 存在模型幻觉问题，请问如何处理?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252-llm" class="md-nav__link">
    <span class="md-ellipsis">
      2.5.2 基于LLM+向量库的文档对话思路是怎么样?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253-llm" class="md-nav__link">
    <span class="md-ellipsis">
      2.5.3 基于LLM+向量库的文档对话核心技术是什么?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#254-llm-prompt" class="md-nav__link">
    <span class="md-ellipsis">
      2.5.4 基于LLM+向量库的文档对话 prompt 模板如何构建?
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>Agent</h1>

<p><a href="https://github.com/InuyashaYang/JoinAI"><img alt="GitHub stars" src="https://img.shields.io/github/stars/InuyashaYang/JoinAI?style=social" /></a></p>
<h2 id="24-langchain">2.4 大模型 langchain<a class="headerlink" href="#24-langchain" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>概念部分</strong></li>
</ul>
<h3 id="241-langchain">2.4.1 什么是LangChain?<a class="headerlink" href="#241-langchain" title="Permanent link">&para;</a></h3>
<p>LangChain是一个用于开发基于大语言模型（LLM）应用程序的强大框架，旨在帮助开发人员简化与大模型交互、数据检索以及将不同功能模块串联起来以完成复杂任务的过程。它由Lang.AI（语言人工智能）开发，是一个开源框架，目前以Python或JavaScript包的形式提供。以下是LangChain的详细介绍：</p>
<p>一、LangChain的核心价值</p>
<ol>
<li><strong>上下文感知能力</strong>：LangChain能够将语言模型连接到上下文源（如提示说明、少量示例、响应内容等），使得应用程序能够更准确地理解用户意图并给出更加准确的回答。</li>
<li><strong>推理能力</strong>：LangChain依赖于语言模型进行推理，根据提供的上下文来回答问题或采取何种行动。它支持多模态、多模型联合推理，通过联合多个预训练模型，提供更强大的语义理解和生成能力。</li>
<li><strong>模块化与易用性</strong>：LangChain的组件都是模块化且易于使用的，支持组合工具、集成环境与语言模型协同运行。它提供了预制链（Off-the-shelf chains），即预先设计和构建好的、可以直接使用的链集合，大大简化了开发过程。</li>
</ol>
<p>二、LangChain的主要组成部分</p>
<ol>
<li><strong>模型（Models）</strong>：LangChain支持各种模型类型和模型集成，包括Google的LaMDA、Meta的LLaMa、OpenAI的GPT-4等。</li>
<li><strong>提示（Prompts）</strong>：包括提示词管理、提示词优化和提示词序列化。提示是模型的输入，一般通过特定的模板组件构建而成，LangChain提供了预先设计好的提示模板，也支持自定义模板。</li>
<li><strong>内存（Memory）</strong>：在链/代理调用之间保持状态的概念。LangChain提供了标准的内存接口、内存实现以及使用内存的链/代理示例。</li>
<li><strong>索引（Indexes）</strong>：与文本数据结合使用时，语言模型往往更加强大。此模块涵盖了执行此操作的最佳实践。</li>
<li><strong>链（Chains）</strong>：不仅仅是单个LLM调用，还包括一系列调用（无论是调用LLM还是不同的实用工具）。LangChain提供了标准的链接口、许多与其他工具的集成，以及用于常见应用程序的端到端的链调用。</li>
<li><strong>代理（Agents）</strong>：涉及LLM做出行动决策、执行该行动、查看一个观察结果，并重复该过程直到完成。LangChain提供了标准的代理接口、一系列可供选择的代理，以及端到端代理的示例。</li>
</ol>
<p>三、LangChain的应用场景</p>
<p>LangChain框架的应用场景非常广泛，几乎涵盖了所有需要语言模型支持的应用领域，包括但不限于：</p>
<ul>
<li><strong>文档分析和摘要</strong>：利用LangChain的上下文感知和推理能力，对大量文档进行自动分析和摘要，提取关键信息。</li>
<li><strong>聊天机器人</strong>：构建具有自然语言处理能力的聊天机器人，实现与用户的自然对话，提供信息咨询、任务执行等功能。</li>
<li><strong>智能助手与自动化</strong>：在办公、教育、医疗等领域，LangChain可以构建智能助手，帮助用户自动化处理日常任务，如日程安排、邮件撰写、研究报告生成等。</li>
<li><strong>代码生成与辅助编程</strong>：帮助开发人员快速生成代码片段、优化代码结构、提供编程建议等。</li>
<li><strong>内容创作与生成</strong>：辅助作家、编辑、广告商等生成高质量的文章、广告文案、社交媒体内容等。</li>
<li><strong>数据科学与分析</strong>：与数据科学工具集成，提供数据清洗、特征工程、模型解释等支持。</li>
<li><strong>法律与合规</strong>：在法律领域，LangChain可以应用于合同审查、法律文档分析、合规性检查等场景。</li>
</ul>
<p>四、LangChain的安装与使用</p>
<p>LangChain是一个Python库，可以通过pip进行安装。在命令行中运行以下命令即可安装LangChain：</p>
<div class="highlight"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>langchain
</code></pre></div>
<p>安装完成后，开发者可以在自己的项目中导入LangChain库，并使用其提供的组件和接口来开发基于LLM的应用程序。</p>
<h3 id="242-langchain">2.4.2 LangChain 包含哪些核心概念?<a class="headerlink" href="#242-langchain" title="Permanent link">&para;</a></h3>
<p>LangChain 包含以下核心概念：</p>
<ol>
<li>
<p><strong>组件（Components）</strong>：LangChain 提供了模块化的组件抽象，用于处理语言模型所需的各种功能，例如模型输入/输出、检索、代理等。</p>
</li>
<li>
<p><strong>链（Chains）</strong>：链是将组件以特定方式组装的集合，用于完成特定的用例。它们可以包含对语言模型的一系列调用，以及与其他工具的交互。</p>
</li>
<li>
<p><strong>代理（Agents）</strong>：代理涉及语言模型对要采取的行动做出决策，执行这些行动，观察结果，然后根据观察结果重复该过程，直到任务完成。</p>
</li>
<li>
<p><strong>用例特定链（Use-case specific chains）</strong>：这些是为特定任务或用例定制的链，提供了更高级别的接口，使得开发人员可以更容易地开始特定用例的开发。</p>
</li>
<li>
<p><strong>LangChain 库（LangChain Libraries）</strong>：提供Python和JavaScript的库，包含组件接口和集成，以及基本的运行时环境，用于组合组件。</p>
</li>
<li>
<p><strong>LangChain 模板（LangChain Templates）</strong>：提供一系列易于部署的参考架构，用于快速启动各种任务。</p>
</li>
<li>
<p><strong>LangServe</strong>：一个库，用于将LangChain链部署为REST API，使得链可以通过网络服务的形式被访问。</p>
</li>
<li>
<p><strong>LangSmith</strong>：一个开发者平台，用于调试、测试、评估和监控基于任何大型语言模型（LLM）框架构建的链，并且与LangChain无缝集成。</p>
</li>
<li>
<p><strong>LangChain 表达式语言（LCEL）</strong>：一种声明性的组合链的方式，支持从原型到生产的过程，无需更改代码。</p>
</li>
<li>
<p><strong>内存（Memory）</strong>：指链/代理调用之间保存状态的概念，LangChain提供标准的内存接口和实现。</p>
</li>
<li>
<p><strong>自定义工具（Custom Tools）</strong>：允许开发者定义自己的工具，以提供给代理使用，增强应用程序的功能。</p>
</li>
<li>
<p><strong>错误处理（Error Handling）</strong>：LangChain 提供了错误处理机制，例如 <code>ToolException</code>，以及通过 <code>handle_tool_error</code> 属性来自定义错误处理策略。</p>
</li>
</ol>
<p>这些概念共同构成了LangChain框架的基础，使其成为一个强大且灵活的开发平台，适用于构建各种由语言模型驱动的应用程序。</p>
<h3 id="243-langchain-agent">2.4.3 什么是LangChain Agent?<a class="headerlink" href="#243-langchain-agent" title="Permanent link">&para;</a></h3>
<p>LangChain Agent（LangChain代理）是LangChain框架中的一个核心概念，它代表了一种能够利用语言模型（LLM）和其他工具来执行复杂任务的系统。以下是LangChain Agent的详细解释：</p>
<p>一、定义与功能</p>
<ul>
<li><strong>定义</strong>：在LangChain中，Agent是一种处理自然语言任务的软件实体或模型组件，它能够根据输入的指令和上下文信息，调用不同的工具（如搜索引擎、数据库查询、API调用等）来获取所需的信息，并将这些信息整合起来形成最终的响应。</li>
<li><strong>功能</strong>：Agent在LangChain中扮演着一个协调者和决策者的角色，它能够根据给定的任务和目标，决定使用哪些工具以及如何组合这些工具来达到目的。Agent的设计目的是为了处理那些简单的语言模型可能无法直接解决的问题，尤其是当这些任务涉及到多个步骤或者需要外部数据源的情况。</li>
</ul>
<p>二、核心思想</p>
<ul>
<li><strong>操作选择</strong>：Agent使用语言模型来选择一系列要执行的操作（AgentAction），这些操作代表了代理应采取的具体步骤。</li>
<li><strong>动态选择</strong>：与Chain（链）的固定路径不同，Agent可以根据上下文动态选择工具和执行策略，这使得它能够更灵活地应对各种复杂场景。</li>
</ul>
<p>三、组成与结构</p>
<ul>
<li><strong>工具（Tools）</strong>：Agent由多个工具组成，每个工具负责单一任务，如Web搜索、数据库查询等。工具是Agent执行单个任务的主要组件。</li>
<li><strong>工具包（Toolkits）</strong>：工具包是工具与预定义操作的组合，可以在Agent中使用。它提供了一种便捷的方式来组织和管理工具集合。</li>
<li><strong>推理引擎</strong>：语言模型在Agent中作为推理引擎使用，它根据输入的指令和上下文信息来确定要执行哪些操作以及按什么顺序执行。</li>
</ul>
<p>四、适用场景</p>
<ul>
<li><strong>网络搜索</strong>：Agent可以集成搜索引擎工具，根据用户输入自动搜索相关信息并生成响应。</li>
<li><strong>嵌入式搜索</strong>：在特定领域或应用中嵌入搜索功能，提供更精确的搜索结果。</li>
<li><strong>API集成</strong>：Agent可以调用外部API获取数据或执行特定操作，以完成复杂任务。</li>
</ul>
<p>五、创建与使用</p>
<ul>
<li><strong>定义工具</strong>：首先，需要定义Agent将使用的工具集合，这些工具可以是内置的也可以是自定义的。</li>
<li><strong>初始化执行器</strong>：使用AgentExecutor来初始化Agent的执行环境，包括加载工具和设置执行参数。</li>
<li><strong>设置提示词</strong>：为Agent设置合适的提示词，以引导语言模型的行为和输出。</li>
<li><strong>执行任务</strong>：通过调用AgentExecutor的invoke方法传入输入指令，Agent将执行一系列操作并生成最终响应。</li>
</ul>
<h3 id="244-langchain">2.4.4 如何使用LangChain?<a class="headerlink" href="#244-langchain" title="Permanent link">&para;</a></h3>
<p>使用 LangChain 构建应用程序通常涉及以下步骤：</p>
<ol>
<li>
<p><strong>了解 LangChain 组件</strong>：熟悉 LangChain 提供的各种组件，例如模型 I/O、检索、代理、内存和链。</p>
</li>
<li>
<p><strong>设置环境</strong>：根据你的开发环境和需求，安装 LangChain 库。LangChain 支持 Python 和 JavaScript。</p>
</li>
<li>
<p><strong>定义问题或用例</strong>：明确你想要解决的问题或你想要实现的用例。</p>
</li>
<li>
<p><strong>选择或创建组件</strong>：根据你的用例，选择或创建必要的 LangChain 组件。这可能包括提示模板、模型集成、数据检索器等。</p>
</li>
<li>
<p><strong>构建链（Chains）</strong>：使用 LangChain 的组件来构建链，这些链定义了如何将组件组合起来以完成特定的任务。</p>
</li>
<li>
<p><strong>创建代理（Agents）</strong>：如果需要，创建代理来执行更复杂的任务，这可能包括决策制定和工具使用。</p>
</li>
<li>
<p><strong>实现自定义逻辑</strong>：根据需要实现自定义逻辑，例如自定义函数或工具。</p>
</li>
<li>
<p><strong>测试和迭代</strong>：测试你的应用程序，并根据反馈进行迭代改进。</p>
</li>
<li>
<p><strong>部署</strong>：当你的应用程序准备好后，使用 LangServe 或其他方法将其部署为服务。</p>
</li>
<li>
<p><strong>监控和评估</strong>：使用 LangSmith 或其他工具来监控和评估你的应用程序的性能。</p>
</li>
</ol>
<p>下面是一个简化的使用 LangChain 的示例流程：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 安装 LangChain</span>
<span class="c1"># pip install langchain</span>

<span class="c1"># 导入 LangChain 库</span>
<span class="kn">from</span> <span class="nn">langchain.llms</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span> <span class="nn">langchain.prompts</span> <span class="kn">import</span> <span class="n">ChatPromptTemplate</span>

<span class="c1"># 创建语言模型实例</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">()</span>

<span class="c1"># 定义一个提示模板</span>
<span class="n">prompt_template</span> <span class="o">=</span> <span class="s2">&quot;What is the capital of </span><span class="si">{country}</span><span class="s2">?&quot;</span>

<span class="c1"># 创建一个提示实例</span>
<span class="n">prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span><span class="n">prompt_template</span><span class="p">)</span>

<span class="c1"># 构建链，将提示和模型组合起来</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">model</span>

<span class="c1"># 执行链，获取结果</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;country&quot;</span><span class="p">:</span> <span class="s2">&quot;France&quot;</span><span class="p">})</span>

<span class="c1"># 打印结果</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
<p>这只是一个基础示例。LangChain 的实际使用可能会更复杂，涉及到更多的组件和自定义逻辑。你可以通过阅读 LangChain 的官方文档和教程来获取更详细的指导和高级用法。</p>
<p>### 2.4.5 LangChain 支持哪些功能?</p>
<p>LangChain 支持一系列功能，以帮助开发者构建由语言模型驱动的应用程序。以下是一些主要功能：</p>
<ol>
<li>
<p><strong>语言模型集成</strong>：支持与各种大型语言模型（LLMs）的集成，包括但不限于 OpenAI 的 GPT 系列模型。</p>
</li>
<li>
<p><strong>模块化组件</strong>：提供模块化的组件抽象，包括模型输入/输出、检索、代理、内存等，以支持构建复杂的应用程序。</p>
</li>
<li>
<p><strong>用例特定链</strong>：允许开发者根据特定用例组装组件，形成高效的工作流程。</p>
</li>
<li>
<p><strong>代理（Agents）</strong>：支持创建代理，这些代理能够理解指令、做出决策、执行操作，并根据结果进行迭代。</p>
</li>
<li>
<p><strong>自定义函数和工具</strong>：允许开发者定义和使用自定义函数和工具，以增强应用程序的功能。</p>
</li>
<li>
<p><strong>LangChain 表达式语言（LCEL）</strong>：提供一种声明性的方式来组合链，支持从原型到生产的过程。</p>
</li>
<li>
<p><strong>内存管理</strong>：提供标准的内存接口，允许在链或代理调用之间保存和使用状态。</p>
</li>
<li>
<p><strong>错误处理</strong>：提供错误处理机制，允许开发者自定义错误处理策略。</p>
</li>
<li>
<p><strong>部署支持</strong>：通过 LangServe 支持将 LangChain 链部署为 REST API。</p>
</li>
<li>
<p><strong>开发者平台</strong>：通过 LangSmith 提供开发者平台，支持调试、测试、评估和监控应用程序。</p>
</li>
<li>
<p><strong>模板和示例</strong>：提供易于部署的参考架构和示例，帮助开发者快速启动项目。</p>
</li>
<li>
<p><strong>生态系统集成</strong>：作为丰富的工具生态系统的一部分，LangChain 支持与多种工具和服务的集成。</p>
</li>
<li>
<p><strong>API 参考</strong>：提供完整的 API 参考文档，方便开发者查找和使用 LangChain 的类和方法。</p>
</li>
<li>
<p><strong>安全性和最佳实践</strong>：提供安全最佳实践指南，帮助开发者安全地使用 LangChain 进行开发。</p>
</li>
<li>
<p><strong>社区和支持</strong>：通过 LangChainHub、Discord 等社区资源，提供分享、探索和讨论的平台。</p>
</li>
</ol>
<p>这些功能共同构成了 LangChain 的强大能力，使其成为一个灵活、可扩展的开发框架，适用于各种语言模型驱动的应用程序。</p>
<p>### 2.4.6 什么是LangChain model?</p>
<p>这些模型通常是大型语言模型（LLM）或聊天模型（Chat Model），它们构成了LangChain框架中自然语言处理任务的基础。</p>
<p>LangChain框架支持多种类型的模型，包括但不限于：</p>
<ol>
<li><strong>大型语言模型（LLM）</strong>：</li>
<li>这些模型是许多语言模型应用程序的支柱，它们将文本字符串作为输入并返回文本字符串作为输出。</li>
<li>LLM能够理解和生成自然语言文本，支持多种语言处理任务，如文本生成、文本分类、情感分析等。</li>
<li>
<p>LangChain为LLM提供了通用的接口，降低了开发者的学习成本，使得开发者能够快速地开发复杂的LLM应用。</p>
</li>
<li>
<p><strong>聊天模型（Chat Model）</strong>：</p>
</li>
<li>聊天模型是语言模型的一个变体，它们以语言模型为基础，但具有更结构化的API。</li>
<li>聊天模型不再以简单的文本字符串为输入和输出，而是将聊天信息列表作为输入和输出，这使得它们更适合于构建聊天机器人等应用。</li>
<li>LangChain支持聊天模型，并提供了与聊天模型交互的接口和工具。</li>
</ol>
<p>除了上述两种主要的模型类型外，LangChain还可能支持其他类型的模型，具体取决于框架的版本和更新情况。</p>
<p>LangChain框架通过提供一套工具、组件和接口，帮助开发人员轻松地构建和管理与语言模型的交互。这些工具包括提示模板（PromptTemplate）、输出解析器（Output Parser）等，它们使得开发人员能够根据需要定制和优化模型的输入和输出，以实现特定的自然语言处理任务。</p>
<p>此外，LangChain还支持链（Chain）和代理（Agent）等高级功能，这些功能允许开发人员将多个模型或组件链接在一起，形成复杂的自然语言处理流程。通过链和代理，开发人员可以构建出功能强大的自然语言处理应用程序，如智能问答系统、文档摘要工具、聊天机器人等。</p>
<h3 id="247-langchain">2.4.7 LangChain 包含哪些特点?<a class="headerlink" href="#247-langchain" title="Permanent link">&para;</a></h3>
<p>LangChain作为一个基于语言模型开发应用程序的强大框架，具有多个显著的特点，这些特点使其在自然语言处理（NLP）领域具有广泛的应用和重要的价值。以下是LangChain的主要特点：</p>
<ol>
<li>支持多种大语言模型</li>
</ol>
<p>LangChain支持多种预训练的大型语言模型（LLM）和聊天模型（Chat Model），如GPT-3.5、GPT-4、BERT、Meta的LLaMa等。这使得开发者能够根据需要选择合适的模型，构建出符合应用场景需求的语言处理系统。</p>
<ol>
<li>丰富的工具和库</li>
</ol>
<p>LangChain集成了大量用于处理自然语言任务的工具和库，包括文本清洗、分词、特征提取、模型训练等。这些工具和库都经过精心设计和优化，帮助开发者更加高效地完成大语言模型的构建和训练。</p>
<ol>
<li>模块化设计</li>
</ol>
<p>LangChain采用模块化设计，将不同的功能和组件封装成独立的模块，如模型（Models）、提示（Prompts）、内存（Memory）、链（Chains）、代理（Agents）等。这种设计使得开发者可以轻松地组合和定制这些模块，以构建出符合自己需求的语言处理系统。</p>
<ol>
<li>高度集成和灵活性</li>
</ol>
<p>LangChain提供了丰富的接口和工具，方便开发者将LLM与外部计算和数据来源结合起来，构建端到端的应用程序。它支持多种编程语言和平台，如Python和TypeScript，使得开发者能够根据自己的喜好和项目需求选择合适的开发环境。</p>
<ol>
<li>上下文感知和推理能力</li>
</ol>
<p>LangChain具有强大的上下文感知和推理能力，能够将多个预训练模型进行联合推理，从而提供更强大的语义理解和生成能力。这使得它能够处理复杂的自然语言任务，如对话生成、文本摘要、知识问答等。</p>
<ol>
<li>可视化工具</li>
</ol>
<p>为了方便开发者更好地理解和调试大语言模型，LangChain还提供了一系列的可视化工具，如模型训练过程的可视化、模型输出的可视化等。这些工具可以帮助开发者更好地了解模型的性能和表现，及时发现和解决问题。</p>
<ol>
<li>社区支持和不断更新</li>
</ol>
<p>LangChain是一个开源项目，拥有活跃的社区支持和不断更新的特性。开发者可以通过社区获取帮助和分享经验，同时也可以关注LangChain的更新和扩展，以便更好地利用这个框架来构建自己的语言处理系统。</p>
<h3 id="248-langchain">2.4.8 LangChain 存在哪些问题及方法方案?<a class="headerlink" href="#248-langchain" title="Permanent link">&para;</a></h3>
<p>LangChain 是一个用于构建由语言模型驱动的应用程序的框架，它提供了模块化的组件和用例特定的链，以支持开发者创建智能应用程序。然而，LangChain 也面临一些问题和挑战。</p>
<p>首先，LangChain 的抽象程度被一些用户认为过高，这在初期可能简化开发，但随着需求的复杂化，这种高级抽象可能导致代码难以理解和维护，增加了开发人员在理解和调试上的负担。此外，LangChain 的不灵活性在面对复杂需求时可能成为阻碍生产力和创新的限制因素。</p>
<p>一些团队和技术评论者指出，LangChain 在生产环境中使用时存在问题，例如难以根据特定业务逻辑动态更改代理的可用工具，以及缺乏从外部观察代理状态的方法。这些问题导致一些团队决定停止使用 LangChain，并采用更灵活的方法来构建他们的应用程序。</p>
<p>针对这些问题，LangChain 可能需要进一步的改进和调整，以提高其灵活性和可定制性，从而更好地适应不同开发团队的需求。同时，开发者在考虑使用 LangChain 时，应该权衡其提供的工具和组件的便利性与可能带来的限制和复杂性。</p>
<p>另外，一些用户认为 LangChain 的学习曲线相对较高，特别是对于初次接触大型语言模型和相关技术栈的开发者。而且，集成多个外部系统和工具可能会增加项目的复杂性，管理这些依赖关系和确保它们之间的兼容性可能成为一项挑战。性能与资源消耗也是考虑因素之一，大型语言模型本身在处理复杂任务时可能消耗较多计算资源，LangChain 虽然提供了优化手段，但在某些应用场景下，资源管理和成本控制仍需精细考虑。</p>
<h3 id="249-langchain">2.4.9 LangChain 替代方案?<a class="headerlink" href="#249-langchain" title="Permanent link">&para;</a></h3>
<p>LangChain 是一个流行的框架，用于构建由语言模型驱动的应用程序，但它也有一些替代品。以下是一些 LangChain 的替代方案：</p>
<ol>
<li><strong>Auto-GPT</strong>：一个旨在使 GPT-4 成为自给自足的聊天 AI 的项目，专注于执行代码和命令来解决问题 。</li>
<li><strong>LlamaIndex</strong>：这是一个多功能的数据管理工具，可以从多种来源提取数据，并优化数据格式以供 LLMs 更好地理解 。</li>
<li><strong>Simpleaichat</strong>：一个专为聊天应用设计的 Python 包，简化了代码并保持了功能强大 。</li>
<li><strong>Outlines</strong>：一个允许开发者精确控制文本生成的工具，提供多种生成方法以保证输出符合特定模式 。</li>
<li><strong>BabyAGI</strong>：一个 Python 脚本，使用 AI 管理任务，结合了 OpenAI、LangChain 和一些向量数据库 。</li>
<li><strong>AgentGPT</strong>：为企业设计的解决方案，通过网页浏览器引入自给自足的 AI 代理 。</li>
<li><strong>MetaGPT</strong>：一个多代理框架，目标是运行一个整个的软件开发公司 。</li>
<li><strong>AutoChain</strong>：结合了 LangChain 和 AutoGPT 的创新方法，为开发者提供灵活的框架来创建代理 。</li>
<li><strong>PromptChainer</strong>：帮助创建 AI 驱动的流程，管理 AI 生成的洞察力 。</li>
<li><strong>TikToken</strong> TikToken 是 OpenAI 开发的 Python 库，它提供了一种简单且高效的方法来计算文本字符串中的令牌，无需使用像 LangChain 这样的复杂框架来完成特定任务。TikToken 可以更直接地处理令牌计数问题，提高处理小数据集时的效率。</li>
<li><strong>Deepset Haystack</strong> Deepset Haystack 是一个开源框架，用于使用大型语言模型构建搜索和问答应用程序。它基于 Hugging Face Transformers，提供了多种查询和理解文本数据的工具。Haystack 旨在简化搜索和问答系统的开发过程，并提供了丰富的功能和定制选项，以满足不同应用场景的需求。</li>
</ol>
<p>这些替代品提供了不同的功能和优势，可以根据你的具体需求和偏好选择使用。例如，如果你需要一个能够处理多种数据类型并优化数据格式的工具，可以考虑使用 LlamaIndex 。如果你更倾向于一个简单易用的聊天应用框架，Simpleaichat 可能是一个不错的选择 。</p>
<ul>
<li><strong>基础技术部分</strong></li>
</ul>
<p>### 2.4.11 LangChain 中 Components and Chains 是什么?</p>
<p>在 LangChain 中，"Components"（组件）和 "Chains"（链）是两个核心概念，它们共同构成了构建应用程序的基础。</p>
<p>一、Components（组件）</p>
<p>Components 是 LangChain 中用于执行特定任务的独立模块。它们是可重用的构建块，可以与其他组件结合以创建更复杂的功能。以下是 LangChain 中一些主要类型的组件：</p>
<ol>
<li><strong>Prompt Templates</strong>（提示模板）: 用于生成语言模型的输入提示。</li>
<li><strong>Output Parsers</strong>（输出解析器）: 解析语言模型的输出，以便进一步处理。</li>
<li><strong>Chains</strong>（链）: 将多个组件按顺序执行的集合。</li>
<li><strong>LLMs (Language Models)</strong>（语言模型）: 执行语言理解或生成任务的大型语言模型。</li>
<li><strong>Indexes</strong>（索引）: 用于存储和检索信息的数据库或搜索引擎。</li>
<li><strong>Agents</strong>（代理）: 能够执行任务、做出决策并采取行动的智能体。</li>
<li><strong>Memory</strong>（内存）: 用于在多个交互中保持状态和上下文的组件。</li>
</ol>
<p>二、 Chains（链）</p>
<p>Chains 是 LangChain 中的一系列有序的组件调用，它们共同完成一个特定的任务或工作流程。链可以看作是组件的管道，其中每个组件对数据进行处理，并将其传递给链中的下一个组件。以下是 LangChain 中链的一些关键特点：</p>
<ol>
<li><strong>有序性</strong>: 链中的组件按照特定的顺序执行，数据在组件之间流动。</li>
<li><strong>可定制性</strong>: 开发者可以根据需要选择和组合不同的组件来创建链。</li>
<li><strong>可重用性</strong>: 一旦定义了一个链，它可以在多个地方重用，提高开发效率。</li>
<li><strong>灵活性</strong>: 链可以根据不同的用例进行调整，以适应不同的需求。</li>
</ol>
<p>三、Components 和 Chains 的关系</p>
<p>组件和链之间的关系可以类比于构建模块和结构。组件是构建模块，它们提供了基本的功能；而链则是使用这些模块构建的结构，它们定义了组件如何协同工作以解决更复杂的问题。</p>
<p>在 LangChain 中，开发者可以定义自己的组件，然后将这些组件组合成链，以创建满足特定需求的应用程序。例如，一个简单的问答应用程序可能包括以下组件链：</p>
<ol>
<li><strong>Prompt Template</strong>: 创建一个提示模板，用于向用户提问。</li>
<li><strong>LLM</strong>: 使用语言模型生成答案。</li>
<li><strong>Output Parser</strong>: 解析模型的输出，提取有用的信息。</li>
</ol>
<p>通过这种方式，LangChain 允许开发者以模块化和灵活的方式构建复杂的应用程序。</p>
<p>### 2.4.12 LangChain 中 Prompt Templates and Values 是什么?
在 LangChain 中，"Prompt Templates"（提示模板）和 "Values"（值）是构建与语言模型交互的提示（prompts）的关键元素。</p>
<p>一、Prompt Templates（提示模板）
提示模板是用于生成发送给语言模型的输入文本的蓝图。它们通常包含一些占位符，这些占位符在运行时会被具体的值所替换。提示模板的目的是标准化与语言模型的交互，确保输入的一致性和预期的结构。提示模板可以包含文本、问题或指令，它们被设计为引导语言模型以特定的方式响应。</p>
<p>例如，一个简单的提示模板可能是：
<div class="highlight"><pre><span></span><code>&quot;What is the capital of {country}?&quot;
</code></pre></div>
在这个模板中，<code>{country}</code> 是一个占位符，它将在实际使用时被具体的国家名称所替换。</p>
<p>二、Values（值）
值是提示模板中占位符的具体替换内容。在使用提示模板生成最终的提示文本时，你需要提供相应的值来填充模板中的占位符。这些值可以是动态的，根据用户的输入或其他上下文信息变化。</p>
<p>继续上面的例子，如果用户想知道法国的首都，那么替换后的值将是 "France"，生成的最终提示将是：
<div class="highlight"><pre><span></span><code>&quot;What is the capital of France?&quot;
</code></pre></div></p>
<p>三、 Prompt Templates 和 Values 的关系
提示模板和值之间的关系是模板化和数据填充的关系。模板定义了提示的结构和所需的信息类型，而值提供了模板中所需的具体数据。这种分离允许开发者创建灵活的系统，可以根据不同的情况生成不同的提示，而不需要每次都从头开始编写文本。</p>
<p>在 LangChain 的上下文中，这种机制允许开发者构建复杂的交互式应用程序，其中语言模型可以根据用户提供的信息或应用程序的内部状态生成响应。通过使用提示模板和值，可以确保与语言模型的交互既灵活又一致。</p>
<p>### 2.4.13 LangChain 中 Example Selectors 是什么?</p>
<p>LangChain中的Example Selectors是一个关键组件，它允许用户为模型提供示例输入和输出，以帮助模型学习执行特定的任务。以下是关于Example Selectors的详细解释：</p>
<p>一、定义与功能</p>
<ul>
<li><strong>定义</strong>：Example Selectors是LangChain框架中的一个组件，用于选择和提供示例数据给模型，以便模型能够学习或优化其执行特定任务的能力。</li>
<li><strong>功能</strong>：</li>
<li><strong>训练新模型</strong>：为全新的模型提供训练数据，让模型学习执行给定的任务。</li>
<li><strong>调优现有模型</strong>：对于现有的模型，Example Selectors可以提供新的示例来继续训练和调优模型，提高其在特定任务上的表现。</li>
<li><strong>测试模型</strong>：也可以用来提供测试用例，评估模型在给定任务上的性能。</li>
<li><strong>说明模型能力</strong>：通过Example Selectors，用户可以直观地了解模型的能力范围，看它能处理什么样的输入并给出什么样的输出。</li>
<li><strong>调试模型</strong>：如果模型在某些示例上表现不佳，Example Selectors可以帮助用户定位并解决问题。</li>
</ul>
<p>二、使用场景</p>
<ul>
<li>在与大语言模型（LLMs）交互时，Example Selectors尤其有用。当需要模型从大量示例中学习和生成特定类型的输出时，通过Example Selectors可以高效地选择和提供这些示例。</li>
<li>对于知识密集型任务，如问答系统、文本摘要等，Example Selectors可以帮助模型更好地理解问题背景，并基于相关示例生成更准确的回答。</li>
</ul>
<p>三、实现方式</p>
<ul>
<li>在LangChain中，用户可以通过自定义Example Selector来满足特定需求。自定义Example Selector通常需要继承自BaseExampleSelector，并实现add_example和select_examples两个抽象方法。</li>
<li><strong>add_example</strong>：用于向selector中添加一个示例。</li>
<li><strong>select_examples</strong>：根据输入，从已添加的示例中选出要使用的示例。</li>
<li>通过这种方式，用户可以灵活地控制哪些示例被用于模型的训练、调优或测试过程中。</li>
</ul>
<p>四、优势</p>
<ul>
<li><strong>提高模型性能</strong>：通过提供有针对性的示例数据，可以帮助模型更快地学习和优化其性能。</li>
<li><strong>降低成本</strong>：在使用第三方大语言模型时，通过合理选择和提供示例数据，可以降低因过多无效输入而产生的费用。</li>
<li><strong>增强可解释性</strong>：通过查看模型在特定示例上的表现，用户可以更直观地了解模型的能力和局限性。</li>
</ul>
<p>### 2.4.14 LangChain 中 Output Parsers 是什么?</p>
<p>LangChain 中的 <code>Output Parsers</code> 是一个组件，它用于解析模型生成的输出。在自然语言处理（NLP）任务中，模型可能会生成复杂的输出，例如长文本、列表、表格或其他结构化数据。<code>Output Parsers</code> 的作用是将这些复杂的输出转换成更易于理解和使用的格式。</p>
<p><code>Output Parsers</code> 可以定制化以满足特定的解析需求，例如：</p>
<ul>
<li>从文本中提取特定的信息，如日期、地点、人名等。</li>
<li>将输出转换为JSON或XML等结构化格式。</li>
<li>对输出进行语义解析，以执行进一步的逻辑操作或数据存储。</li>
</ul>
<p>在LangChain框架中，<code>Output Parsers</code> 通常与 <code>Prompts</code> 和 <code>Example Selectors</code> 结合使用，以创建一个完整的NLP工作流。通过精心设计的提示（Prompts），模型可以生成预期的输出，然后 <code>Output Parsers</code> 将这些输出解析成所需的格式。</p>
<p>例如，如果你正在构建一个聊天机器人，你可能需要一个 <code>Output Parser</code> 来解析模型生成的回复，并确保它们是合适的、语法正确的，并且符合对话的上下文。或者，如果你正在构建一个信息提取系统，<code>Output Parser</code> 可能会用于从文本中提取关键信息并将其存储在数据库中。</p>
<p>LangChain 提供了灵活性，允许开发者根据他们的特定需求实现自定义的 <code>Output Parser</code>。这样，无论是简单的文本清理还是复杂的数据提取任务，都可以有效地实现。</p>
<p>### 2.4.15 LangChain 中 Indexes and Retrievers 是什么?</p>
<p>在LangChain框架中，<code>Indexes</code> 和 <code>Retrievers</code> 是两个关键组件，它们用于管理和检索大量的数据或文档。</p>
<p>一、 Indexes
<code>Indexes</code> 是一种数据结构，用于存储和组织信息，以便可以快速检索。在LangChain中，索引通常用于以下目的：
- <strong>存储文档</strong>：将文本、问题和答案等数据存储在索引中，以便于后续检索。
- <strong>快速搜索</strong>：提供快速的搜索功能，以便用户可以迅速找到所需的信息。
- <strong>数据组织</strong>：通过索引，数据可以按照不同的标准（如日期、作者、主题等）进行组织。</p>
<p>二、 Retrievers
<code>Retrievers</code> 是执行检索操作的组件，它们使用索引来查找和提取信息。<code>Retrievers</code> 的功能包括：
- <strong>基于查询的检索</strong>：根据用户的查询，从索引中检索相关的文档或信息。
- <strong>过滤和排序</strong>：对检索结果进行过滤和排序，以提供最相关的结果。
- <strong>高效访问</strong>：确保用户可以高效地访问存储在索引中的信息。</p>
<p>在LangChain中，<code>Indexes</code> 和 <code>Retrievers</code> 通常与以下场景结合使用：
- <strong>问答系统</strong>：在问答系统中，<code>Retrievers</code> 可以根据用户的问题从索引中检索最相关的答案。
- <strong>信息检索</strong>：在需要从大量文档中检索特定信息的场景中，<code>Retrievers</code> 可以快速找到并返回相关信息。
- <strong>知识库管理</strong>：在构建知识库时，<code>Indexes</code> 可以帮助组织和管理知识库中的信息，而 <code>Retrievers</code> 则用于检索知识库中的条目。</p>
<p>LangChain支持多种类型的索引和检索器，包括但不限于基于向量的索引（如使用嵌入向量进行相似性搜索的索引）和传统的基于文本的索引。开发者可以根据具体需求选择合适的索引和检索策略，以实现最优的检索效果。</p>
<p>### 2.4.16 LangChain 中 Chat Message History 是什么?</p>
<p>在LangChain框架中，<code>Chat Message History</code> 指的是在聊天应用或对话系统中，用于存储和管理对话历史记录的组件或机制。这个历史记录包括用户和聊天机器人之间交换的所有消息，它可以用于多种目的：</p>
<ol>
<li>
<p><strong>上下文理解</strong>：通过分析对话历史，聊天机器人可以更好地理解当前对话的上下文，从而提供更准确和相关的响应。</p>
</li>
<li>
<p><strong>个性化体验</strong>：<code>Chat Message History</code> 可以帮助聊天机器人记住用户的偏好和需求，从而提供更加个性化的服务。</p>
</li>
<li>
<p><strong>对话连贯性</strong>：对话历史确保了对话的连贯性，使得聊天机器人能够在对话过程中保持话题的一致性。</p>
</li>
<li>
<p><strong>数据挖掘和分析</strong>：对话历史可以用于分析用户行为，提取常见问题，优化聊天机器人的性能。</p>
</li>
<li>
<p><strong>训练数据</strong>：对话历史可以作为训练数据，帮助改进聊天机器人的模型，使其更加智能。</p>
</li>
<li>
<p><strong>用户行为追踪</strong>：在某些情况下，对话历史还可以用于追踪用户的行为模式，以提供定制化的推荐或服务。</p>
</li>
</ol>
<p>在实现上，<code>Chat Message History</code> 可以是一个简单的列表或数组，其中存储了对话中每条消息的文本、发送者（用户或机器人）、时间戳等信息。更高级的实现可能包括对消息的语义分析、情感分析等，以提供更深层次的理解和响应。</p>
<p>LangChain作为一个灵活的框架，允许开发者根据自己的需求来设计和实现<code>Chat Message History</code>，以支持复杂的对话管理和分析任务。</p>
<p>### 2.4.17 LangChain 中 Agents and Toolkits 是什么?</p>
<p>在LangChain框架中，<code>Agents</code> 和 <code>Toolkits</code> 是两个关键概念，它们共同构成了LangChain生态系统的核心部分。</p>
<p>一、Agents</p>
<p><code>Agents</code> 在LangChain中指的是执行特定任务或操作的智能体。这些智能体可以是独立的，也可以是协作的，它们可以执行以下类型的任务：
- <strong>数据检索</strong>：从数据库或知识库中检索信息。
- <strong>信息提取</strong>：从文本中提取关键信息或实体。
- <strong>自然语言理解</strong>：理解用户的查询或指令的意图。
- <strong>对话管理</strong>：在多轮对话中维护上下文和连贯性。
- <strong>任务执行</strong>：执行特定的业务逻辑或用户请求的任务。</p>
<p><code>Agents</code> 可以被设计为具有不同的能力和权限，它们可以相互通信和协作，以解决复杂的用户需求。</p>
<p>二、Toolkits</p>
<p><code>Toolkits</code> 是LangChain提供的工具集合，它们为开发者提供了一系列的工具和库，以便构建和集成各种智能应用。<code>Toolkits</code> 包括但不限于：
- <strong>数据存储和检索工具</strong>：用于管理大量数据的存储和快速检索。
- <strong>自然语言处理工具</strong>：包括语言模型、文本分析、情感分析等。
- <strong>机器学习工具</strong>：用于训练和部署机器学习模型。
- <strong>对话管理工具</strong>：用于构建和管理对话流程。
- <strong>集成开发环境</strong>：提供代码编辑、调试和部署的工具。</p>
<p><code>Toolkits</code> 旨在简化开发过程，提供标准化的接口和组件，使开发者能够快速构建和部署智能应用。</p>
<p>三、Agents 和 Toolkits 的关系</p>
<p><code>Agents</code> 和 <code>Toolkits</code> 在LangChain中是相互依赖的。<code>Agents</code> 利用 <code>Toolkits</code> 提供的工具和能力来执行任务，而 <code>Toolkits</code> 则为 <code>Agents</code> 提供了执行任务所需的基础设施和支持。这种设计允许LangChain生态系统具有高度的灵活性和可扩展性，开发者可以根据具体需求选择合适的 <code>Agents</code> 和 <code>Toolkits</code> 来构建定制化的解决方案。</p>
<p>通过结合使用 <code>Agents</code> 和 <code>Toolkits</code>，LangChain支持构建复杂的智能系统，这些系统可以处理各种复杂的任务，从简单的信息检索到复杂的对话管理和任务自动化。</p>
<p>### 2.4.18 LangChain 如何调用LLMs生成回复?</p>
<p>LangChain调用LLMs（大语言模型）生成回复的过程相对直接且灵活，主要通过其提供的API接口和工具集来实现。以下是一个概括性的步骤说明：</p>
<ol>
<li>初始化LLM实例</li>
</ol>
<p>首先，你需要根据所使用的LLM（如OpenAI、Cohere、Hugging Face等）初始化一个LLM实例。这通常涉及到设置LLM的API密钥或其他必要的认证信息。</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain.llms</span> <span class="kn">import</span> <span class="n">OpenAI</span>
<span class="n">llm</span> <span class="o">=</span> <span class="n">OpenAI</span><span class="p">(</span><span class="n">openai_api_key</span><span class="o">=</span><span class="s2">&quot;YOUR_API_KEY&quot;</span><span class="p">)</span>
</code></pre></div>
<ol>
<li>构造提示（Prompt）</li>
</ol>
<p>接下来，你需要构造一个提示（Prompt），这是你将发送给LLM的输入文本。这个提示应该清晰地描述你想要LLM完成的任务或生成的内容。</p>
<div class="highlight"><pre><span></span><code><span class="n">prompt</span> <span class="o">=</span> <span class="s2">&quot;请给我写一首关于夏天的诗。&quot;</span>
</code></pre></div>
<ol>
<li>调用LLM生成回复</li>
</ol>
<p>有了LLM实例和提示之后，你就可以调用LLM的方法来生成回复了。LangChain提供了多种方式来调用LLM，包括直接调用和异步调用等。</p>
<ul>
<li><strong>直接调用</strong>：</li>
</ul>
<p>直接调用LLM的<code>generate</code>或类似方法，并传入提示作为参数。</p>
<div class="highlight"><pre><span></span><code><span class="n">response</span> <span class="o">=</span> <span class="n">llm</span><span class="o">.</span><span class="n">generate</span><span class="p">([</span><span class="n">prompt</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>
<p>注意：<code>generate</code>方法的具体用法可能因LLM的不同而有所差异，上述代码以OpenAI为例。</p>
<ul>
<li><strong>异步调用</strong>：</li>
</ul>
<p>如果你需要同时调用多个LLM或处理大量请求，可以使用异步调用来提高效率。LangChain支持异步调用OpenAI等LLM。</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generate</span><span class="p">(</span><span class="n">llm</span><span class="p">,</span> <span class="n">prompt</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="k">await</span> <span class="n">llm</span><span class="o">.</span><span class="n">agenerate</span><span class="p">([</span><span class="n">prompt</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

<span class="c1"># 假设你已经有了llm实例</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">async_generate</span><span class="p">(</span><span class="n">llm</span><span class="p">,</span> <span class="n">prompt</span><span class="p">))</span>
</code></pre></div>
<ol>
<li>处理回复</li>
</ol>
<p>最后，你需要处理LLM生成的回复。这可能包括解析回复内容、提取有用信息、格式化输出等。LangChain提供了输出解析（Output Parsers）等工具来帮助你完成这些任务。</p>
<ol>
<li>附加功能</li>
</ol>
<p>除了基本的调用LLM生成回复外，LangChain还提供了许多附加功能来增强LLM的应用效果，如：</p>
<ul>
<li><strong>缓存</strong>：对于重复的请求，LangChain提供了缓存功能来避免重复调用LLM，从而节省时间和成本。</li>
<li><strong>流式处理</strong>：对于需要长时间生成大量内容的请求，LangChain支持流式处理，可以逐步返回生成的内容，提高用户体验。</li>
<li><strong>自定义LLM</strong>：如果LangChain没有直接支持你想要使用的LLM，你可以通过继承LangChain的<code>LLM</code>基类来自定义LLM接口。</li>
</ul>
<p>### 2.4.19 LangChain 如何修改提示模板?</p>
<p>根据需求，可以通过以下几种方式修改提示模板：</p>
<ol>
<li>
<p><strong>直接修改模板字符串</strong>：
   如果提示模板是以字符串形式直接定义的，可以直接在代码中修改这个字符串。例如，将模板中的某个词替换为另一个词，或者调整句子的结构。</p>
</li>
<li>
<p><strong>使用PromptTemplate类</strong>：
   在LangChain中，通常会使用<code>PromptTemplate</code>类来创建和管理提示模板。可以通过修改<code>PromptTemplate</code>实例的<code>template</code>属性来更新模板内容。例如：
   <div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain.prompts</span> <span class="kn">import</span> <span class="n">PromptTemplate</span>

<span class="c1"># 假设已有一个PromptTemplate实例</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">(</span><span class="n">input_variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;product&quot;</span><span class="p">],</span> <span class="n">template</span><span class="o">=</span><span class="s2">&quot;What is a good name for a company that makes </span><span class="si">{product}</span><span class="s2">?&quot;</span><span class="p">)</span>

<span class="c1"># 修改模板内容</span>
<span class="n">template</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;Please suggest a name for a company specializing in </span><span class="si">{product}</span><span class="s2"> production.&quot;</span>

<span class="c1"># 使用修改后的模板</span>
<span class="n">prompt</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">product</span><span class="o">=</span><span class="s2">&quot;eco-friendly water bottles&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
</code></pre></div></p>
</li>
</ol>
<p>注意：直接修改<code>template</code>属性可能不是所有情况下都推荐的做法，因为这可能涉及到对模板状态的直接操作，有时可能会导致不可预见的问题。更常见的做法是先创建一个新的<code>PromptTemplate</code>实例，然后替换旧的实例。</p>
<ol>
<li>
<p><strong>通过方法修改</strong>：
   如果<code>PromptTemplate</code>类提供了修改模板内容的方法（虽然标准的<code>PromptTemplate</code>类可能不直接提供这样的方法），那么可以通过调用这些方法来修改模板。但在大多数情况下，直接修改字符串或创建新实例更为直接和简单。</p>
</li>
<li>
<p><strong>使用版本控制</strong>：
   在修改提示模板时，建议使用版本控制工具（如Git）来跟踪和管理模板的变更历史。这有助于在需要时回滚到之前的版本，并确保团队成员之间的同步。</p>
</li>
</ol>
<p>### 2.4.20 LangChain 如何链接多个组件处理一个特定的下游任务?</p>
<p>LangChain 是一个灵活的框架，允许开发者通过链接多个组件来处理特定的下游任务。这种链式调用方式可以充分利用每个组件的能力，形成一个强大的工作流。以下是使用LangChain链接组件处理下游任务的一般步骤：</p>
<ol>
<li>
<p><strong>定义任务需求</strong>：明确你想要完成的下游任务是什么，以及需要哪些组件来实现它。</p>
</li>
<li>
<p><strong>选择组件</strong>：根据任务需求，选择适当的LangChain组件。这可能包括数据检索器、示例选择器、提示模板、语言模型、输出解析器等。</p>
</li>
<li>
<p><strong>配置组件</strong>：为每个组件配置必要的参数和设置。这可能包括API密钥、模型选择、示例数据、模板内容等。</p>
</li>
<li>
<p><strong>设计工作流</strong>：设计一个工作流，明确组件之间的数据流向和交互方式。决定哪些组件是顺序执行的，哪些可以并行处理。</p>
</li>
<li>
<p><strong>实现数据传递</strong>：实现组件之间的数据传递机制。这可能涉及到定义输入输出接口、使用共享数据结构等。</p>
</li>
<li>
<p><strong>编写代码</strong>：根据设计的工作流，编写代码来链接各个组件。使用LangChain提供的API和接口来实现组件的调用和数据传递。</p>
</li>
<li>
<p><strong>测试和调试</strong>：在开发过程中，不断测试每个组件和整个工作流，确保它们按预期工作，并调试任何出现的问题。</p>
</li>
<li>
<p><strong>优化和调整</strong>：根据测试结果，对工作流和组件进行优化和调整，以提高性能和准确性。</p>
</li>
<li>
<p><strong>部署和监控</strong>：将完成的工作流部署到生产环境，并持续监控其性能和稳定性。</p>
</li>
</ol>
<p>以下是一个简化的代码示例，展示了如何在LangChain中链接多个组件来处理一个简单的问答任务：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain.agents</span> <span class="kn">import</span> <span class="n">Agent</span>
<span class="kn">from</span> <span class="nn">langchain.retrievers</span> <span class="kn">import</span> <span class="n">MyRetriever</span>
<span class="kn">from</span> <span class="nn">langchain.example_selectors</span> <span class="kn">import</span> <span class="n">MyExampleSelector</span>
<span class="kn">from</span> <span class="nn">langchain.prompts</span> <span class="kn">import</span> <span class="n">MyPromptTemplate</span>
<span class="kn">from</span> <span class="nn">langchain.llms</span> <span class="kn">import</span> <span class="n">MyLanguageModel</span>
<span class="kn">from</span> <span class="nn">langchain.output_parsers</span> <span class="kn">import</span> <span class="n">MyOutputParser</span>

<span class="c1"># 实例化组件</span>
<span class="n">retriever</span> <span class="o">=</span> <span class="n">MyRetriever</span><span class="p">()</span>
<span class="n">example_selector</span> <span class="o">=</span> <span class="n">MyExampleSelector</span><span class="p">()</span>
<span class="n">prompt_template</span> <span class="o">=</span> <span class="n">MyPromptTemplate</span><span class="p">()</span>
<span class="n">llm</span> <span class="o">=</span> <span class="n">MyLanguageModel</span><span class="p">()</span>
<span class="n">output_parser</span> <span class="o">=</span> <span class="n">MyOutputParser</span><span class="p">()</span>

<span class="c1"># 定义一个Agent来协调各个组件</span>
<span class="k">class</span> <span class="nc">MyAgent</span><span class="p">(</span><span class="n">Agent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="c1"># 使用检索器获取相关信息</span>
        <span class="n">documents</span> <span class="o">=</span> <span class="n">retriever</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="c1"># 使用示例选择器选择相关示例</span>
        <span class="n">examples</span> <span class="o">=</span> <span class="n">example_selector</span><span class="o">.</span><span class="n">select_examples</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>

        <span class="c1"># 使用提示模板生成提示</span>
        <span class="n">prompt</span> <span class="o">=</span> <span class="n">prompt_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">examples</span><span class="p">)</span>

        <span class="c1"># 使用语言模型生成回复</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">llm</span><span class="o">.</span><span class="n">generate_response</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>

        <span class="c1"># 使用输出解析器解析回复</span>
        <span class="n">parsed_response</span> <span class="o">=</span> <span class="n">output_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parsed_response</span>

<span class="c1"># 创建Agent实例并执行任务</span>
<span class="n">agent</span> <span class="o">=</span> <span class="n">MyAgent</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;How does the internal combustion engine work?&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
<p>### 2.4.21 LangChain 如何Embedding &amp; vector store?</p>
<p>LangChain 提供了强大的文本嵌入（Embedding）和向量存储（Vector Store）功能，以支持复杂的自然语言处理（NLP）任务。以下是 LangChain 如何进行文本嵌入和向量存储的详细步骤：</p>
<p>一、 文本嵌入（Embedding）</p>
<ol>
<li>
<p><strong>导入嵌入模型</strong>：
   LangChain 支持多种文本嵌入模型，如 OpenAI Embeddings、Hugging Face Embeddings 等。首先需要导入所需的嵌入模型。例如，使用 OpenAI Embeddings 的代码如下：
   <div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain.embeddings</span> <span class="kn">import</span> <span class="n">OpenAIEmbeddings</span>
<span class="n">embeddings</span> <span class="o">=</span> <span class="n">OpenAIEmbeddings</span><span class="p">()</span>
</code></pre></div></p>
</li>
<li>
<p><strong>创建嵌入向量</strong>：
   使用嵌入模型的 <code>embed_query</code> 或 <code>embed_documents</code> 方法为文本创建嵌入向量。这两个方法分别用于嵌入单个查询文本和多个文档文本。例如：
   <div class="highlight"><pre><span></span><code><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;This is a sample text.&quot;</span>
<span class="n">query_embedding</span> <span class="o">=</span> <span class="n">embeddings</span><span class="o">.</span><span class="n">embed_query</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="n">documents</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hi there!&quot;</span><span class="p">,</span> <span class="s2">&quot;Oh, hello!&quot;</span><span class="p">,</span> <span class="s2">&quot;What&#39;s your name?&quot;</span><span class="p">]</span>
<span class="n">document_embeddings</span> <span class="o">=</span> <span class="n">embeddings</span><span class="o">.</span><span class="n">embed_documents</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
</code></pre></div></p>
</li>
<li>
<p><strong>缓存嵌入</strong>：
   为了提高效率，可以使用 <code>CacheBackedEmbeddings</code> 类来缓存嵌入结果，避免重复计算。例如：
   <div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain.embeddings</span> <span class="kn">import</span> <span class="n">CacheBackedEmbeddings</span>
<span class="kn">from</span> <span class="nn">langchain.storage</span> <span class="kn">import</span> <span class="n">LocalFileStore</span>

<span class="n">underlying_embeddings</span> <span class="o">=</span> <span class="n">OpenAIEmbeddings</span><span class="p">()</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">LocalFileStore</span><span class="p">(</span><span class="s2">&quot;./cache/&quot;</span><span class="p">)</span>
<span class="n">cached_embedder</span> <span class="o">=</span> <span class="n">CacheBackedEmbeddings</span><span class="o">.</span><span class="n">from_bytes_store</span><span class="p">(</span><span class="n">underlying_embeddings</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">underlying_embeddings</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
</code></pre></div></p>
</li>
</ol>
<p>二、 向量存储（Vector Store）</p>
<ol>
<li>
<p><strong>选择合适的向量存储</strong>：
   LangChain 支持多种向量存储后端，如 Chroma、FAISS、Qdrant、Weaviate 等。需要根据实际需求选择合适的存储后端。</p>
</li>
<li>
<p><strong>创建向量存储实例</strong>：
   使用选定的向量存储和嵌入模型创建向量存储实例。例如，使用 Chroma 存储嵌入向量的代码如下：
   <div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain.vectorstores</span> <span class="kn">import</span> <span class="n">Chroma</span>
<span class="kn">from</span> <span class="nn">langchain.docstore.document</span> <span class="kn">import</span> <span class="n">Document</span>

<span class="n">docs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Document</span><span class="p">(</span><span class="n">page_content</span><span class="o">=</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">documents</span><span class="p">]</span>
<span class="n">vector_store</span> <span class="o">=</span> <span class="n">Chroma</span><span class="o">.</span><span class="n">from_documents</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">)</span>
</code></pre></div></p>
</li>
</ol>
<p>或者使用 FAISS：
   <div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">langchain_community.vectorstores</span> <span class="kn">import</span> <span class="n">FAISS</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">FAISS</span><span class="o">.</span><span class="n">from_documents</span><span class="p">(</span><span class="n">documents</span><span class="p">,</span> <span class="n">cached_embedder</span><span class="p">)</span>
</code></pre></div></p>
<ol>
<li><strong>进行相似性搜索</strong>：
   使用向量存储的 <code>similarity_search</code> 方法进行相似性搜索。输入一个查询文本（也转换为嵌入向量），返回与该查询最相似的文档列表。例如：
   <div class="highlight"><pre><span></span><code><span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;What is this text about?&quot;</span>
<span class="n">query_embedding</span> <span class="o">=</span> <span class="n">embeddings</span><span class="o">.</span><span class="n">embed_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">vector_store</span><span class="o">.</span><span class="n">similarity_search</span><span class="p">(</span><span class="n">query_embedding</span><span class="p">)</span>
</code></pre></div></li>
</ol>
<p>注意：在上面的 FAISS 示例中，由于 FAISS 通常接受文档嵌入而不是查询嵌入作为输入来构建索引，因此在实际应用中，你可能需要先将查询嵌入与文档嵌入存储在同一个向量空间中，或者使用其他方法来处理查询嵌入。</p>
<p>### 2.4.22 LangChain 低效的令牌使用问题</p>
<p>在LangChain或任何使用语言模型（LLMs）的系统中，"低效的令牌使用"可能指的是几种不同的问题，其中最常见的是：</p>
<ol>
<li>
<p><strong>令牌限制导致的截断</strong>：大多数语言模型对输入和输出的令牌数量有限制。如果输入文本超过了这个限制，它将被截断，可能导致模型无法理解完整的上下文。</p>
</li>
<li>
<p><strong>冗余令牌</strong>：在提示（prompts）或输入中使用不必要的令牌，这不仅浪费令牌配额，而且可能使模型难以捕捉到关键信息。</p>
</li>
<li>
<p><strong>无效的令牌分配</strong>：在多轮对话或复杂查询中，令牌可能没有被有效分配，导致某些重要信息被忽略或无法充分表达。</p>
</li>
</ol>
<p>为了解决或优化LangChain中的令牌使用问题，可以考虑以下策略：</p>
<ul>
<li>
<p><strong>精简输入</strong>：确保输入文本尽可能简洁，去除无关紧要的词汇或冗余信息。</p>
</li>
<li>
<p><strong>优化提示设计</strong>：设计清晰、精确的提示，避免不必要的复杂性，确保每个令牌都用于传达重要信息。</p>
</li>
<li>
<p><strong>使用令牌高效的格式</strong>：在多轮对话中，使用列表或表格等格式来组织信息，可以更有效地利用令牌。</p>
</li>
<li>
<p><strong>分步处理</strong>：对于长对话或复杂任务，考虑将其分解为多个步骤，每步使用较少的令牌。</p>
</li>
<li>
<p><strong>动态令牌管理</strong>：根据对话的进展动态调整输入和输出的令牌使用，例如，在确定用户需求后，可以减少冗余的解释和背景信息。</p>
</li>
<li>
<p><strong>利用上下文管理</strong>：在多轮对话中，有效地利用模型的上下文记忆能力，避免重复之前已经提供的信息。</p>
</li>
<li>
<p><strong>测试和评估</strong>：通过测试不同的输入长度和复杂度，评估模型的响应质量和效率，找到最佳的令牌使用平衡点。</p>
</li>
<li>
<p><strong>使用高效的模型</strong>：如果可能，选择更高效的模型，这些模型能够在较少的令牌限制下提供更好的性能。</p>
</li>
<li>
<p><strong>用户反馈循环</strong>：允许用户提供反馈，根据反馈调整令牌的使用策略，以更好地满足用户需求。</p>
</li>
</ul>
<p>请注意，LangChain作为一个框架，提供了工具和接口来帮助开发者优化令牌的使用，但具体的优化策略可能需要根据应用场景和用户需求来定制。</p>
<p>### 2.4.23 LangChain 太多概念容易混淆，过多的“辅助”函数问题</p>
<p>LangChain 作为一个复杂的自然语言处理（NLP）框架，确实包含了大量的概念和“辅助”函数，这些设计初衷是为了提供灵活性和强大的功能，但同时也可能让新用户感到困惑和难以上手。以下是一些解决 LangChain 概念混淆和过多“辅助”函数问题的方法：</p>
<ol>
<li>
<p>清晰的概念划分和文档</p>
</li>
<li>
<p><strong>概念划分</strong>：在文档中明确区分和解释各个概念，包括它们的作用、区别以及相互之间的关系。使用图表、流程图或示例代码来辅助说明。</p>
</li>
<li>
<p><strong>术语标准化</strong>：确保文档中使用的术语是一致的，并对关键术语进行定义和解释。</p>
</li>
<li>
<p>分层次的文档结构</p>
</li>
<li>
<p><strong>入门指南</strong>：提供一个简洁的入门指南，帮助新用户快速了解 LangChain 的基本概念和主要功能。</p>
</li>
<li><strong>高级教程</strong>：对于已经有一定基础的用户，提供详细的高级教程，介绍更复杂的用法和最佳实践。</li>
<li>
<p><strong>参考手册</strong>：包含所有函数、类和方法的详细文档，方便用户查找特定信息。</p>
</li>
<li>
<p>示例和模板</p>
</li>
<li>
<p><strong>示例代码</strong>：提供丰富的示例代码，涵盖不同的使用场景和任务。示例代码应该具有代表性和可复制性，以便用户能够轻松地学习和实践。</p>
</li>
<li>
<p><strong>模板项目</strong>：创建一些模板项目，这些项目展示了如何使用 LangChain 构建不同类型的 NLP 应用。用户可以根据模板项目快速开始自己的项目。</p>
</li>
<li>
<p>社区和支持</p>
</li>
<li>
<p><strong>活跃的社区</strong>：建立一个活跃的社区，让用户能够交流经验、分享知识和解答问题。社区中的专家和用户可以提供宝贵的建议和指导。</p>
</li>
<li>
<p><strong>官方支持</strong>：提供官方支持渠道，如论坛、邮件列表或聊天室，以便用户能够直接获得来自 LangChain 团队或其他专家的帮助。</p>
</li>
<li>
<p>精简和整合“辅助”函数</p>
</li>
<li>
<p><strong>评估需求</strong>：定期评估“辅助”函数的使用情况和反馈，了解哪些函数是真正有用的，哪些可能是多余的。</p>
</li>
<li><strong>整合功能</strong>：对于功能相似或重复的“辅助”函数，考虑进行整合和简化，以减少用户的认知负担。</li>
<li>
<p><strong>提供默认配置</strong>：为常用的“辅助”函数提供合理的默认配置，以减少用户需要设置的参数数量。</p>
</li>
<li>
<p>教育和培训</p>
</li>
<li>
<p><strong>在线课程</strong>：提供免费的在线课程或教程，帮助用户系统地学习 LangChain 的概念和功能。</p>
</li>
<li><strong>工作坊和研讨会</strong>：组织定期的工作坊和研讨会，邀请专家和用户一起探讨 LangChain 的最佳实践和应用场景。</li>
</ol>
<p>通过这些方法，可以逐步解决 LangChain 概念混淆和过多“辅助”函数的问题，提高用户的体验和满意度。同时，这也需要 LangChain 团队和社区的持续努力和支持。</p>
<h3 id="2424-langchain">2.4.24 LangChain 行为不一致并且隐藏细节问题<a class="headerlink" href="#2424-langchain" title="Permanent link">&para;</a></h3>
<p>在使用LangChain或其他复杂的框架时，可能会遇到行为不一致和隐藏细节的问题。这些问题可能源于多种原因，例如框架的内部逻辑复杂、文档不完整或更新不及时、API的变更等。以下是一些解决和缓解这些问题的策略：</p>
<ol>
<li>
<p><strong>详细阅读文档</strong>：确保你阅读了最新版本的官方文档，以了解所有功能和行为的预期。</p>
</li>
<li>
<p><strong>查看变更日志</strong>：检查框架的变更日志，了解最近的更新和可能影响现有代码的变更。</p>
</li>
<li>
<p><strong>理解内部机制</strong>：尽可能深入理解LangChain的内部工作机制，这有助于预测和解释行为。</p>
</li>
<li>
<p><strong>使用版本控制</strong>：使用版本控制系统（如Git）来跟踪你的代码更改，确保你可以回滚到之前的稳定版本。</p>
</li>
<li>
<p><strong>编写单元测试</strong>：为你的代码编写单元测试，这可以帮助捕捉不一致的行为，并确保代码按预期工作。</p>
</li>
<li>
<p><strong>错误处理</strong>：确保你的代码有健壮的错误处理和日志记录，以便在出现问题时快速定位。</p>
</li>
<li>
<p><strong>社区和论坛</strong>：参与LangChain的社区和论坛，与其他用户交流经验，了解他们如何处理类似的问题。</p>
</li>
</ol>
<h3 id="2425-langchain">2.4.25 LangChain 缺乏标准的可互操作数据类型问题<a class="headerlink" href="#2425-langchain" title="Permanent link">&para;</a></h3>
<p>在构建像LangChain这样的框架时，确保数据类型的标准化和可互操作性是非常重要的。这有助于简化开发流程、提高代码的可维护性，并允许不同组件或模块之间无缝协作。以下是一些解决或缓解LangChain中缺乏标准可互操作数据类型问题的方法：</p>
<ol>
<li>
<p><strong>定义清晰的数据模型</strong>：为LangChain中使用的数据定义清晰的数据模型和接口。这包括输入、输出以及中间数据的格式。</p>
</li>
<li>
<p><strong>使用标准化的数据格式</strong>：尽可能使用广泛接受的标准化数据格式，如JSON、XML或Protocol Buffers，这些格式具有良好的互操作性。</p>
</li>
<li>
<p><strong>创建抽象层</strong>：在LangChain中实现一个抽象层，以统一不同组件之间的数据交换格式。</p>
</li>
<li>
<p><strong>数据序列化和反序列化</strong>：确保LangChain提供数据序列化和反序列化的工具，以支持不同数据格式之间的转换。</p>
</li>
<li>
<p><strong>API设计</strong>：设计一致的API，这些API可以接收和返回标准化的数据类型。</p>
</li>
<li>
<p><strong>文档和类型定义</strong>：在文档中清晰地定义数据类型和结构，使用类型定义语言（如YAML或OpenAPI）来描述API的输入和输出。</p>
</li>
<li>
<p><strong>类型检查和验证</strong>：在LangChain中实现类型检查和验证机制，确保数据在处理过程中符合预期的类型。</p>
</li>
<li>
<p><strong>使用类型系统</strong>：利用编程语言的类型系统来定义和检查数据类型，减少类型错误和不一致性。</p>
</li>
<li>
<p><strong>提供数据转换工具</strong>：提供工具或函数来帮助开发者在不同数据类型之间进行转换。</p>
</li>
</ol>
<h2 id="25-llm">2.5 基于LLM+向量库的文档对话<a class="headerlink" href="#25-llm" title="Permanent link">&para;</a></h2>
<h3 id="251-llms">2.5.1 LLMs 存在模型幻觉问题，请问如何处理?<a class="headerlink" href="#251-llms" title="Permanent link">&para;</a></h3>
<p>LLMs（大型语言模型）存在的模型幻觉问题是一个复杂且需要多方面解决的难题。模型幻觉指的是LLMs生成看似合理但实际上不正确、与输入不符、与先前生成的内容矛盾或与已知世界知识不符的内容。为了处理这一问题，可以采取以下策略：</p>
<ol>
<li>
<p>数据清洗和预处理</p>
</li>
<li>
<p><strong>重要性</strong>：在训练LLMs之前，对数据进行仔细的清洗和预处理是至关重要的。</p>
</li>
<li>
<p><strong>措施</strong>：删除不准确、噪声或有偏差的数据，以减少模型幻觉问题的出现。这有助于确保模型在训练过程中接触到的是高质量、一致性的数据。</p>
</li>
<li>
<p>多样化训练数据</p>
</li>
<li>
<p><strong>目的</strong>：为了减少LLMs对特定数据源的依赖和偏好。</p>
</li>
<li>
<p><strong>实施</strong>：尽量使用多样化的训练数据，包括来自不同领域、不同来源和不同观点的数据。这有助于模型获得更全面的语言理解和更广泛的知识基础。</p>
</li>
<li>
<p>引入多样性的生成策略</p>
</li>
<li>
<p><strong>方法</strong>：在生成文本时，可以采用多样性的生成策略来减少模型的倾向性和幻觉问题。</p>
</li>
<li>
<p><strong>示例</strong>：使用温度参数来调整生成的多样性，或者使用抽样和束搜索等不同的生成方法。这些策略可以帮助模型在生成文本时避免陷入固定的模式或偏见。</p>
</li>
<li>
<p>人工审核和后处理</p>
</li>
<li>
<p><strong>作用</strong>：对生成的文本进行人工审核和后处理是一种常用的方法。</p>
</li>
<li>
<p><strong>实施</strong>：通过人工的干预和修正，可以纠正模型幻觉问题，并确保生成的内容准确和可靠。虽然这种方法需要人力投入，但它是目前最有效的保障内容质量的手段之一。</p>
</li>
<li>
<p>引入外部知识和约束</p>
</li>
<li>
<p><strong>方法</strong>：为了提高生成文本的准确性，可以引入外部知识和约束。</p>
</li>
<li>
<p><strong>示例</strong>：结合知识图谱、实体识别或逻辑推理等技术，将先验知识和约束融入到生成过程中。这些方法可以帮助模型在生成文本时参考更广泛、更准确的知识来源，从而减少幻觉问题的发生。</p>
</li>
<li>
<p>改进模型架构和训练算法</p>
</li>
<li>
<p><strong>方向</strong>：研究并改进LLMs的架构和训练算法，以减少幻觉问题的根源。</p>
</li>
<li>
<p><strong>措施</strong>：例如，通过优化模型的注意力机制、引入记忆机制或改进损失函数等方式，提高模型对上下文和全局信息的理解能力，从而减少幻觉的生成。</p>
</li>
<li>
<p>增强模型的上下文理解能力</p>
</li>
<li>
<p><strong>重要性</strong>：LLMs在生成文本时往往依赖于上下文信息。因此，增强模型的上下文理解能力是减少幻觉问题的关键。</p>
</li>
<li>
<p><strong>措施</strong>：可以通过增加模型的层数、改进编码方式或引入额外的上下文表示等方法，提高模型对上下文信息的捕捉和处理能力。</p>
</li>
<li>
<p>持续监测和评估</p>
</li>
<li>
<p><strong>必要性</strong>：由于LLMs的幻觉问题可能随着时间和数据的变化而变化，因此持续监测和评估模型的表现是必要的。</p>
</li>
<li><strong>实施</strong>：建立有效的评估机制，定期测试模型在不同任务和数据集上的表现，并根据评估结果及时调整和优化模型。</li>
</ol>
<p>综上所述，处理LLMs的模型幻觉问题需要综合考虑数据、模型、算法和人工干预等多个方面。通过实施上述策略，可以逐步减少模型幻觉问题的发生，提高LLMs的准确性和可靠性。</p>
<h3 id="252-llm">2.5.2 基于LLM+向量库的文档对话思路是怎么样?<a class="headerlink" href="#252-llm" title="Permanent link">&para;</a></h3>
<p>基于LLM（大型语言模型）+向量库的文档对话思路，主要围绕将外部知识库与LLM结合，以提高文档对话的准确性和效率。以下是详细的思路步骤：</p>
<p>一、总体思路</p>
<p>通过将用户知识库内容经过embedding存入向量知识库，然后用户每一次提问也会经过embedding，利用向量相关性算法（如余弦算法）找到最匹配的几个知识库片段。将这些知识库片段作为上下文，与用户问题一起作为prompt提交给LLM，以生成最终的回答。</p>
<p>二、具体步骤</p>
<ol>
<li><strong>加载文件</strong>：</li>
<li>
<p>使用适当的库（如PyMuPDF、docx等）将包含要对话的文档文件（如PDF、Word、TXT等）加载到系统中。</p>
</li>
<li>
<p><strong>文本预处理</strong>：</p>
</li>
<li>
<p>将加载的文件内容读取成纯文本格式，并进行必要的预处理，如去除多余的空格和特殊字符。</p>
</li>
<li>
<p><strong>文本分割</strong>：</p>
</li>
<li>
<p>为了便于向量化处理和提高检索效率，将长文本分割成较小的段落或句子。可以使用自然语言处理技术进行段落或句子的分割，常用的方法包括按段落、句子或固定长度进行分割。</p>
</li>
<li>
<p><strong>文本向量化</strong>：</p>
</li>
<li>
<p>利用预训练的语言模型（如BERT、GPT等）将分割后的文本转换为向量表示。这些向量捕捉了文本的语义信息，便于后续的相似度计算和检索。常用的工具和库包括Transformers、Sentence-Transformers等。</p>
</li>
<li>
<p><strong>问题向量化</strong>：</p>
</li>
<li>
<p>将用户输入的问题也转换为向量表示，以便与文档向量进行匹配。</p>
</li>
<li>
<p><strong>向量检索</strong>：</p>
</li>
<li>
<p>利用相似性度量（如余弦相似度）在文本向量库中找到与问句向量最相似的Top K个向量。这一步可以使用快速检索算法（如FAISS）来提高匹配效率。</p>
</li>
<li>
<p><strong>构造Prompt</strong>：</p>
</li>
<li>
<p>将找到的最相似的文本段落作为上下文信息，与用户的问题一起形成新的Prompt。这个Prompt将作为LLM的输入，以生成最终的回答。</p>
</li>
<li>
<p><strong>生成回答</strong>：</p>
</li>
<li>将构造好的Prompt提交给预训练的大语言模型（LLM），如GPT-3、ChatGPT等，生成最终的回答。</li>
</ol>
<p>三、优化与改进</p>
<ol>
<li><strong>文档切分粒度</strong>：</li>
<li>
<p>文档切分粒度是一个需要仔细把控的问题。切分过细可能导致噪声过多，切分过粗则可能丢失语义信息。因此，需要根据实际情况选择合适的切分粒度，并可能采用语义级别的分割方法，如利用NLP的篇章分析工具或BERT等模型进行语义分割。</p>
</li>
<li>
<p><strong>向量检索效率</strong>：</p>
</li>
<li>
<p>提高向量检索的效率是优化文档对话系统性能的关键。可以使用高效的向量检索工具，如FAISS、Annoy等，来加速相似度计算和向量匹配过程。</p>
</li>
<li>
<p><strong>模型选择与训练</strong>：</p>
</li>
<li>
<p>选择合适的LLM模型对于生成高质量的回答至关重要。同时，根据具体任务的需求，可以对LLM进行微调或训练，以更好地适应特定领域或场景。</p>
</li>
<li>
<p><strong>多模态融合</strong>：</p>
</li>
<li>在某些情况下，文档可能包含多种类型的信息（如文本、图片、表格等）。为了充分利用这些信息，可以考虑将多模态融合技术引入文档对话系统中，以提高系统的综合性能。</li>
</ol>
<p>通过以上步骤和优化措施，可以构建一个基于LLM+向量库的文档对话系统，该系统能够高效地处理用户提问，并生成准确、有用的回答。</p>
<h3 id="253-llm">2.5.3 基于LLM+向量库的文档对话核心技术是什么?<a class="headerlink" href="#253-llm" title="Permanent link">&para;</a></h3>
<p>基于LLM（大型语言模型）+向量库的文档对话核心技术主要涉及到**文本嵌入（Text Embedding）**和**高效检索（Efficient Retrieval）**两个方面。这两个方面共同构成了支撑文档对话系统的关键技术。</p>
<ol>
<li>文本嵌入（Text Embedding）</li>
</ol>
<p>文本嵌入技术是将文本数据转换为固定长度的向量表示，这些向量能够捕捉文本的语义信息，使得在向量空间中相似的文本具有相近的距离。在文档对话系统中，文本嵌入技术被用于将用户提问和文档内容转换为向量，以便进行后续的相似度计算和检索。</p>
<p>常用的文本嵌入方法包括：</p>
<ul>
<li><strong>预训练语言模型</strong>：如BERT、GPT等，这些模型在大量文本数据上进行预训练，能够学习到文本的丰富语义特征，并将这些特征编码到向量中。</li>
<li>
<p><strong>句子嵌入模型</strong>：如Sentence-BERT（SBERT）、Universal Sentence Encoder（USE）等，这些模型专门设计用于生成句子的向量表示，能够在保持较高精度的同时提高计算效率。</p>
</li>
<li>
<p>高效检索（Efficient Retrieval）</p>
</li>
</ul>
<p>在文档对话系统中，面对庞大的文档库，如何实现快速、准确的检索是一个关键问题。高效检索技术能够帮助系统从大量文档中快速找到与用户提问最相关的文档片段，作为后续LLM生成回答的上下文。</p>
<p>常用的高效检索方法包括：</p>
<ul>
<li><strong>向量检索工具</strong>：如FAISS、Annoy等，这些工具利用近似最近邻搜索（Approximate Nearest Neighbor, ANN）算法，在向量空间中快速找到与用户提问向量最相似的文档向量。</li>
<li>
<p><strong>倒排索引</strong>：对于文本数据，还可以使用倒排索引技术来加速检索过程。倒排索引将文档中的词汇映射到包含该词汇的文档列表，通过查询词汇可以快速定位到相关文档。</p>
</li>
<li>
<p>核心技术综合应用</p>
</li>
</ul>
<p>在文档对话系统中，文本嵌入和高效检索技术通常被综合应用：</p>
<ol>
<li><strong>文档向量化</strong>：首先，将文档库中的文档内容进行向量化处理，生成文档向量库。</li>
<li><strong>问题向量化</strong>：当用户提问时，将问题也进行向量化处理，生成问题向量。</li>
<li><strong>向量检索</strong>：在文档向量库中使用高效检索技术找到与问题向量最相似的Top K个文档向量。</li>
<li><strong>Prompt构造</strong>：将检索到的文档片段作为上下文信息，与用户提问一起构造新的Prompt。</li>
<li><strong>回答生成</strong>：将Prompt输入到LLM中，生成最终的回答。</li>
</ol>
<p>通过这种方式，文档对话系统能够充分利用LLM的生成能力和向量库的检索能力，实现高效、准确的文档对话。</p>
<h3 id="254-llm-prompt">2.5.4 基于LLM+向量库的文档对话 prompt 模板如何构建?<a class="headerlink" href="#254-llm-prompt" title="Permanent link">&para;</a></h3>
<p>基于LLM（大型语言模型）+向量库的文档对话prompt模板的构建，是一个结合文本嵌入、高效检索和LLM生成能力的复杂过程。以下是一个构建此类prompt模板的基本框架和步骤：</p>
<p>一、构建思路</p>
<ol>
<li><strong>明确对话目的</strong>：</li>
<li>
<p>确定文档对话的具体目标，如回答问题、提供信息、执行指令等。</p>
</li>
<li>
<p><strong>分析用户提问</strong>：</p>
</li>
<li>
<p>解析用户提问的意图和关键词，理解用户需要的信息类型。</p>
</li>
<li>
<p><strong>检索相关文档</strong>：</p>
</li>
<li>
<p>利用向量库和高效检索技术，找到与用户提问最相关的文档片段。</p>
</li>
<li>
<p><strong>构造上下文Prompt</strong>：</p>
</li>
<li>
<p>将检索到的文档片段作为上下文信息，与用户提问一起构造出完整的Prompt。</p>
</li>
<li>
<p><strong>提交给LLM生成回答</strong>：</p>
</li>
<li>将构造好的Prompt提交给LLM，利用LLM的生成能力生成最终的回答。</li>
</ol>
<p>二、Prompt模板示例</p>
<p>假设用户提问：“请告诉我关于人工智能在医疗领域的应用有哪些？”</p>
<ol>
<li>
<p>检索相关文档</p>
</li>
<li>
<p>使用向量库和高效检索技术，找到与“人工智能 医疗领域 应用”相关的文档片段。</p>
</li>
<li>
<p>构造上下文Prompt</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code>问题：请告诉我关于人工智能在医疗领域的应用有哪些？

上下文信息：
（以下是从向量库中检索到的相关文档片段，作为上下文信息）

* 人工智能在医疗领域的应用日益广泛，包括但不限于辅助诊断、个性化治疗方案制定、患者监测等。
* 通过深度学习算法，AI能够分析大量的医学影像数据，帮助医生更准确地诊断疾病。
* 在个性化治疗方面，AI可以根据患者的基因信息和病情，推荐最适合的治疗方案。
* 此外，AI还可以用于患者监测，通过实时监测患者的生理指标，及时发现异常情况并采取措施。

请基于以上上下文信息，回答用户的问题。
</code></pre></div>
<ol>
<li>
<p>提交给LLM生成回答</p>
</li>
<li>
<p>将上述Prompt提交给LLM，LLM将基于上下文信息和用户提问生成最终的回答。</p>
</li>
</ol>
<p>三、注意事项</p>
<ol>
<li><strong>保持Prompt的简洁性</strong>：</li>
<li>
<p>Prompt应尽可能简洁明了，避免冗长和无关的信息。</p>
</li>
<li>
<p><strong>确保上下文的准确性</strong>：</p>
</li>
<li>
<p>检索到的文档片段应准确反映用户提问的意图和关键词，避免引入噪声信息。</p>
</li>
<li>
<p><strong>考虑LLM的生成能力</strong>：</p>
</li>
<li>
<p>根据所使用的LLM的特点和生成能力，适当调整Prompt的构造方式，以获得更好的回答效果。</p>
</li>
<li>
<p><strong>持续优化Prompt模板</strong>：</p>
</li>
<li>根据实际应用效果和用户反馈，不断优化Prompt模板，提高文档对话的准确性和效率。</li>
</ol>
<p>通过以上步骤和注意事项，可以构建出基于LLM+向量库的文档对话prompt模板，为文档对话系统提供有力支持。</p>
<p><a href="https://github.com/InuyashaYang/JoinAI"><img alt="GitHub stars" src="https://img.shields.io/github/stars/InuyashaYang/JoinAI?style=social" /></a></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/Joining-AI/LLM_Interview_Prepare" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.sections", "navigation.tabs"], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.525ec568.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../javascripts/mathjax_config.js"></script>
      
    
  </body>
</html>